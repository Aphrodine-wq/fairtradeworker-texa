import { useState, useMemo, memo, useCallback } from "react" import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card" import { Button } from "@/components/ui/button" import { Badge } from "@/components/ui/badge" import { Input } from "@/components/ui/input" import { Textarea } from "@/components/ui/textarea" import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs" import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger, } from "@/components/ui/dialog" import { Label } from "@/components/ui/label" import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select" import { useLocalKV as useKV } from "@/hooks/useLocalKV" import { Users, EnvelopeSimple, DeviceMobile, Note, Trash, MagnifyingGlass, Funnel, ChartLine, Calendar, Clock, TrendUp, CurrencyDollar, Target, Sparkle, Phone, ChatCircle, FileText, Tag, Plus, X, CheckCircle, Circle } from "@phosphor-icons/react" import { toast } from "sonner" import { InstantInvite } from "./InstantInvite" import type { User, CRMCustomer, CRMInteraction } from "@/lib/types" interface PipelineStage { id: string name: string customers: CRMCustomer[] } interface CRMDashboardProps { user: User } export const EnhancedCRMDashboard = memo(function EnhancedCRMDashboard({ user }: CRMDashboardProps) { const [customers, setCustomers] = useKV<CRMCustomer[]>("crm-customers", []) const [interactions, setInteractions] = useKV<CRMInteraction[]>("crm-interactions", []) const [selectedCustomer, setSelectedCustomer] = useState<CRMCustomer | null>(null) const [notes, setNotes] = useState("") const [isEditingNotes, setIsEditingNotes] = useState(false) const [searchQuery, setSearchQuery] = useState("") const [statusFilter, setStatusFilter] = useState<string>("all") const [viewMode, setViewMode] = useState<'list' | 'pipeline' | 'analytics'>('list') const [newInteraction, setNewInteraction] = useState<Partial<CRMInteraction>>({ type: 'note', title: '', description: '', date: new Date().toISOString().split('T')[0] }) const [showAddInteraction, setShowAddInteraction] = useState(false) const myCustomers = (customers || []).filter(c => c.contractorId === user.id) // Calculate lead scores const customersWithScores = useMemo(() => { return myCustomers.map(customer => { let score = 0 // Base score by status if (customer.status === 'active') score += 30 else if (customer.status === 'lead') score += 10 // Lifetime value (higher LTV = higher score) if (customer.lifetimeValue > 10000) score += 40 else if (customer.lifetimeValue > 5000) score += 30 else if (customer.lifetimeValue > 1000) score += 20 else if (customer.lifetimeValue > 0) score += 10 // Recent interactions (more recent = higher score) const customerInteractions = getCustomerInteractions(customer.id) const recentInteractions = customerInteractions.filter(i => { const interactionDate = new Date(i.date) const thirtyDaysAgo = new Date() thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30) return interactionDate >= thirtyDaysAgo }) score += Math.min(recentInteractions.length * 5, 20) // Tags (VIP, High Priority, etc.) if (customer.tags?.some(tag => tag.toLowerCase().includes('vip'))) score += 15 if (customer.tags?.some(tag => tag.toLowerCase().includes('priority'))) score += 10 // Source (referrals score higher) if (customer.source === 'referral') score += 10 return { ...customer, leadScore: Math.min(score, 100) } }) }, [myCustomers, interactions]) const filteredCustomers = useMemo(() => { let filtered = customersWithScores if (searchQuery.trim()) { const query = searchQuery.toLowerCase() filtered = filtered.filter(c => c.name.toLowerCase().includes(query) || c.email?.toLowerCase().includes(query) || c.phone?.toLowerCase().includes(query) || c.notes?.toLowerCase().includes(query) || c.tags?.some(tag => tag.toLowerCase().includes(query)) ) } if (statusFilter !== "all") { filtered = filtered.filter(c => c.status === statusFilter) } return filtered.sort((a, b) => ((b as any).leadScore || 0) - ((a as any).leadScore || 0) || new Date(b.invitedAt).getTime() - new Date(a.invitedAt).getTime() ) }, [customersWithScores, searchQuery, statusFilter]) // Pipeline stages const pipelineStages: PipelineStage[] = useMemo(() => { return [ { id: 'lead', name: 'Leads', customers: filteredCustomers.filter(c => c.status === 'lead') }, { id: 'active', name: 'Active', customers: filteredCustomers.filter(c => c.status === 'active') }, { id: 'completed', name: 'Completed', customers: filteredCustomers.filter(c => c.status === 'completed') }, { id: 'advocate', name: 'Advocates', customers: filteredCustomers.filter(c => c.status === 'advocate') }, ] }, [filteredCustomers]) // Get customer interactions (sorted by date, newest first) const getCustomerInteractions = (customerId: string) => { return (interactions || []).filter(i => i.customerId === customerId) .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()) } const getLeadScoreColor = (score: number) => { if (score >= 80) return 'text-green-600 dark:text-green-400 bg-green-50 dark:bg-green-950' if (score >= 60) return 'text-yellow-600 dark:text-yellow-400 bg-yellow-50 dark:bg-yellow-950' if (score >= 40) return 'text-orange-600 dark:text-orange-400 bg-orange-50 dark:bg-orange-950' return 'text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-950' } // Analytics const analytics = useMemo(() => { const totalRevenue = myCustomers.reduce((sum, c) => sum + (c.lifetimeValue || 0), 0) const avgLTV = myCustomers.length > 0 ? totalRevenue / myCustomers.length : 0 const conversionRate = myCustomers.length > 0 ? (myCustomers.filter(c => c.status === 'completed' || c.status === 'advocate').length / myCustomers.length) * 100 : 0 const recentInteractions = (interactions || []).filter(i => { const interactionDate = new Date(i.date) const thirtyDaysAgo = new Date() thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30) return interactionDate >= thirtyDaysAgo }).length return { totalRevenue, avgLTV, conversionRate, recentInteractions, totalCustomers: myCustomers.length, activeCustomers: myCustomers.filter(c => c.status === 'active').length, leads: myCustomers.filter(c => c.status === 'lead').length, } }, [myCustomers, interactions]) const handleSaveNotes = () => { if (!selectedCustomer) return setCustomers((current) => (current || []).map((c) => c.id === selectedCustomer.id ? { ...c, notes: notes.trim() } : c ) ) toast.success("Notes saved!") setIsEditingNotes(false) } const handleAddInteraction = () => { if (!selectedCustomer || !newInteraction.title) { toast.error("Please fill in all required fields") return } const interaction: CRMInteraction = { id: `interaction-${Date.now()}`, customerId: selectedCustomer.id, type: newInteraction.type || 'note', title: newInteraction.title, description: newInteraction.description, date: newInteraction.date || new Date().toISOString(), outcome: newInteraction.outcome, nextAction: newInteraction.nextAction, nextActionDate: newInteraction.nextActionDate, } setInteractions((current) => [...(current || []), interaction]) // Update customer last contact setCustomers((current) => (current || []).map((c) => c.id === selectedCustomer.id ? { ...c, lastContact: interaction.date } : c ) ) toast.success("Interaction added!") setShowAddInteraction(false) setNewInteraction({ type: 'note', title: '', description: '', date: new Date().toISOString().split('T')[0] }) } const handleUpdateStatus = (customerId: string, newStatus: CRMCustomer['status']) => { setCustomers((current) => (current || []).map((c) => c.id === customerId ? { ...c, status: newStatus } : c ) ) toast.success("Status updated!") } const handleDeleteCustomer = (customerId: string, customerName: string) => { setCustomers((current) => (current || []).filter((c) => c.id !== customerId)) setInteractions((current) => (current || []).filter((i) => i.customerId !== customerId)) toast.success(`${customerName} removed from CRM`) setSelectedCustomer(null) } const getStatusColor = (status: CRMCustomer['status']) => { switch (status) { case 'active': return 'bg-white dark:bg-black text-black dark:text-white border-2 border-black dark:border-white"> <h3 className="text-lg font-semibold mb-4 dark:text-white">Recent Activity</h3> <div className="space-y-3"> {(interactions || []).slice(0, 10).map((interaction) => { const customer = myCustomers.find(c => c.id === interaction.customerId) const Icon = getInteractionIcon(interaction.type) return ( <div key={interaction.id} className="flex items-center gap-3 p-3 bg-white dark:bg-black rounded-none border-2 border-black dark:border-white"> <Icon weight="duotone" size={20} className="text-black dark:text-white" /> <div className="flex-1"> <div className="font-semibold dark:text-white">{interaction.title}</div> <div className="text-sm text-black dark:text-white dark:text-white/70"> {customer?.name} â€¢ {formatDateTime(interaction.date)} </div> </div> </div> ) })} {(!interactions || interactions.length === 0) && ( <div className="text-center py-8 text-black dark:text-white dark:text-white/70"> No interactions recorded yet </div> )} </div> </Card> </div> )} </> )} </div> {/* Add Interaction Dialog */} {selectedCustomer && ( <Dialog open={showAddInteraction} onOpenChange={setShowAddInteraction}> <DialogContent className="dark:bg-black dark:border-white/20 overflow-hidden flex flex-col p-0 gap-0 h-[95vh]"> <div className="px-8 pt-6 pb-4 border-2 border-black dark:border-white flex-shrink-0"> <DialogHeader className="text-left"> <DialogTitle className="dark:text-white text-2xl">Add Interaction</DialogTitle> <DialogDescription className="dark:text-white/70"> Record a new interaction with {selectedCustomer.name} </DialogDescription> </DialogHeader> </div> <div className="flex-1 overflow-hidden p-6 grid grid-cols-1 md:grid-cols-2 gap-6"> {/* Left Column */} <div className="space-y-4"> <div className="space-y-2"> <Label className="dark:text-white text-sm">Type</Label> <Select value={newInteraction.type} onValueChange={(value) => setNewInteraction({ ...newInteraction, type: value as any })} > <SelectTrigger className="dark:bg-black dark:text-white dark:border-white/20 h-10"> <SelectValue /> </SelectTrigger> <SelectContent> <SelectItem value="call">Phone Call</SelectItem> <SelectItem value="email">Email</SelectItem> <SelectItem value="meeting">Meeting</SelectItem> <SelectItem value="note">Note</SelectItem> <SelectItem value="bid">Bid Submitted</SelectItem> <SelectItem value="payment">Payment Received</SelectItem> </SelectContent> </Select> </div> <div className="space-y-2"> <Label className="dark:text-white text-sm">Title *</Label> <Input value={newInteraction.title} onChange={(e) => setNewInteraction({ ...newInteraction, title: e.target.value })} placeholder="Brief description of interaction" className="dark:bg-black dark:text-white dark:border-white/20 h-10" /> </div> <div className="space-y-2"> <Label className="dark:text-white text-sm">Date</Label> <Input type="date" value={newInteraction.date} onChange={(e) => setNewInteraction({ ...newInteraction, date: e.target.value })} className="dark:bg-black dark:text-white dark:border-white/20 h-10" /> </div> <div className="space-y-2"> <Label className="dark:text-white text-sm">Outcome</Label> <Select value={newInteraction.outcome} onValueChange={(value) => setNewInteraction({ ...newInteraction, outcome: value as any })} > <SelectTrigger className="dark:bg-black dark:text-white dark:border-white/20 h-10"> <SelectValue placeholder="Select outcome" /> </SelectTrigger> <SelectContent> <SelectItem value="positive">Positive</SelectItem> <SelectItem value="neutral">Neutral</SelectItem> <SelectItem value="negative">Negative</SelectItem> </SelectContent> </Select> </div> </div> {/* Right Column */} <div className="space-y-4 flex flex-col"> <div className="space-y-2"> <Label className="dark:text-white text-sm">Description</Label> <Textarea value={newInteraction.description} onChange={(e) => setNewInteraction({ ...newInteraction, description: e.target.value })} placeholder="Detailed notes about the interaction..." className="flex-1 dark:bg-black dark:text-white dark:border-white/20 resize-none" /> </div> <div className="space-y-2"> <Label className="dark:text-white text-sm">Next Action</Label> <Input value={newInteraction.nextAction} onChange={(e) => setNewInteraction({ ...newInteraction, nextAction: e.target.value })} placeholder="What should happen next?" className="dark:bg-black dark:text-white dark:border-white/20 h-10" /> </div> <div className="space-y-2"> <Label className="dark:text-white text-sm">Next Action Date</Label> <Input type="date" value={newInteraction.nextActionDate} onChange={(e) => setNewInteraction({ ...newInteraction, nextActionDate: e.target.value })} className="dark:bg-black dark:text-white dark:border-white/20 h-10" /> </div> </div> </div> <div className="px-8 py-4 border-2 border-black dark:border-white flex-shrink-0"> <div className="flex gap-3 justify-end"> <Button variant="outline" onClick={() => setShowAddInteraction(false)} className="dark:bg-black dark:text-white dark:border-white/20 h-10" > Cancel </Button> <Button onClick={handleAddInteraction} className="h-10" > Add Interaction </Button> </div> </div> </DialogContent> </Dialog> )} </div> ) }) 